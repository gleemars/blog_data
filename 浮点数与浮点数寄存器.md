---
title: 浮点数与浮点数寄存器
description: 
categories:
tags: 
grammar_cjkRuby: true
---

## ia-32
![enter description here](https://www.github.com/Byzero512/blog_img/raw/master/1537521752921.png)

![enter description here](https://www.github.com/Byzero512/blog_img/raw/master/1537522796206.png)

![enter description here](https://www.github.com/Byzero512/blog_img/raw/master/1537523354922.png)

### 视频连接
https://www.coursera.org/learn/jisuanji-xitong/lecture/mnkzb/w6-6-mmxji-ssezhi-ling-ji

![enter description here](https://www.github.com/Byzero512/blog_img/raw/master/1537519594139.png)

> 注意: 80位拓展中没有隐藏首位有效位

> x87 FPU 特指与 x86处理器配套的浮点协处理器架构
> + 浮点寄存器使用栈结构, 共有 8 个, st0-->st7
> + 在这架构下,所有的浮点数,不管是哪种类型,都用80位存在浮点数寄存器中
> + 浮点数在浮点寄存器和内存中传送
> + 对于long double, 其虽然是 96 位, 但其实只有低80bits有意义

![enter description here](https://www.github.com/Byzero512/blog_img/raw/master/1537519940812.png)


### sse 指令集

> SIMD操作
> MMX指令使用了8个64位寄存器mm0-->mm7,借用了之前的 st0--st7
> sse指令将80位浮点数寄存器拓展了

![sse_comefrom](https://www.github.com/Byzero512/blog_img/raw/master/1537521664855.png)


### x86-64
> 浮点数操作使用 xmm 寄存器,不适用 st 寄存器
![enter description here](https://www.github.com/Byzero512/blog_img/raw/master/1537522916060.png)

![enter description here](https://www.github.com/Byzero512/blog_img/raw/master/1537523219026.png)

![enter description here](https://www.github.com/Byzero512/blog_img/raw/master/1537523594900.png)


### ia-32 和 x86-64 的区别

#### ia-32
1. 浮点数作为参数

> fldl/flds , fstpl
> 内存 --> st  --> 参数区(栈)

![enter description here](https://www.github.com/Byzero512/blog_img/raw/master/1537524227398.png)


#### x86-64     
1. 浮点数作为参数

> 内存 --> xmm
> 如果是printf("%d",double_var);这样子会出问题, 因为%d会认为参数被放到 rsi, 但实际上并没有.
> 所以如果要在64位系统中输出一个浮点数,不能用 "%d"